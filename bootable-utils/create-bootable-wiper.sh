#!/bin/bash

# JNARDDC Secure Data Wiper - Bootable ISO Creation Script\n# Creates a bootable Linux-based data wiping utility\n# Compliance: NIST SP 800-88 Rev. 1\n\nset -e\n\n# Configuration\nWORK_DIR=\"/tmp/secure-wiper-build\"\nISO_NAME=\"JNARDDC-Secure-Wiper-v1.0.iso\"\nVOLUME_LABEL=\"JNARDDC-WIPER\"\nARCH=\"amd64\"\nUBUNTU_VERSION=\"22.04\"\nBUILD_DATE=$(date +\"%Y%m%d\")\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\nlog_info() {\n    echo -e \"${GREEN}[INFO]${NC} $1\"\n}\n\nlog_warn() {\n    echo -e \"${YELLOW}[WARN]${NC} $1\"\n}\n\nlog_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\nlog_step() {\n    echo -e \"${BLUE}[STEP]${NC} $1\"\n}\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n    log_error \"Please run as root (sudo)\"\n    exit 1\nfi\n\n# Check required tools\ncheck_dependencies() {\n    log_step \"Checking dependencies...\"\n    local deps=(\"debootstrap\" \"squashfs-tools\" \"xorriso\" \"isolinux\" \"syslinux-utils\")\n    local missing=()\n    \n    for dep in \"${deps[@]}\"; do\n        if ! command -v \"$dep\" &> /dev/null; then\n            missing+=(\"$dep\")\n        fi\n    done\n    \n    if [ ${#missing[@]} -ne 0 ]; then\n        log_error \"Missing dependencies: ${missing[*]}\"\n        log_info \"Install with: apt-get install ${missing[*]}\"\n        exit 1\n    fi\n    \n    log_info \"All dependencies satisfied\"\n}\n\n# Clean and create work directory\nsetup_workspace() {\n    log_step \"Setting up workspace...\"\n    rm -rf \"$WORK_DIR\"\n    mkdir -p \"$WORK_DIR\"/{image,chroot,iso}\n    log_info \"Workspace created at $WORK_DIR\"\n}\n\n# Create base Ubuntu system\ncreate_base_system() {\n    log_step \"Creating base Ubuntu system...\"\n    \n    debootstrap --arch=\"$ARCH\" \"$UBUNTU_VERSION\" \"$WORK_DIR/chroot\" \\\n        http://archive.ubuntu.com/ubuntu/\n    \n    # Mount required filesystems\n    mount --bind /dev \"$WORK_DIR/chroot/dev\"\n    mount --bind /dev/pts \"$WORK_DIR/chroot/dev/pts\"\n    mount --bind /proc \"$WORK_DIR/chroot/proc\"\n    mount --bind /sys \"$WORK_DIR/chroot/sys\"\n    \n    log_info \"Base system created\"\n}\n\n# Configure the chroot environment\nconfigure_system() {\n    log_step \"Configuring system...\"\n    \n    # Copy DNS configuration\n    cp /etc/resolv.conf \"$WORK_DIR/chroot/etc/resolv.conf\"\n    \n    # Create configuration script\n    cat > \"$WORK_DIR/chroot/configure.sh\" << 'EOF'\n#!/bin/bash\n\n# Update package lists\napt-get update\n\n# Install required packages\napt-get install -y \\\n    linux-image-generic \\\n    live-boot \\\n    systemd-sysv \\\n    casper \\\n    discover \\\n    laptop-detect \\\n    os-prober \\\n    network-manager \\\n    resolvconf \\\n    net-tools \\\n    wireless-tools \\\n    wpagui \\\n    locales \\\n    linux-generic \\\n    grub-common \\\n    grub-gfxpayload-lists \\\n    grub-pc \\\n    grub-pc-bin \\\n    grub2-common \\\n    memtest86+ \\\n    parted \\\n    gdisk \\\n    hdparm \\\n    smartmontools \\\n    secure-delete \\\n    wipe \\\n    shred \\\n    dc3dd \\\n    ddrescue \\\n    python3 \\\n    python3-pip \\\n    python3-tk \\\n    nodejs \\\n    npm \\\n    dialog \\\n    whiptail \\\n    zenity \\\n    x11-xserver-utils \\\n    xinit \\\n    xterm \\\n    openbox \\\n    lxde-core\n\n# Install NIST-compliant wiping tools\npip3 install cryptography pycryptodome\n\n# Configure locale\nlocale-gen en_US.UTF-8\necho 'LANG=en_US.UTF-8' > /etc/default/locale\n\n# Configure live user\nuseradd -m -s /bin/bash -G sudo live\necho \"live:live\" | chpasswd\necho \"live ALL=(ALL) NOPASSWD: ALL\" >> /etc/sudoers\n\n# Configure automatic login\nmkdir -p /etc/systemd/system/getty@tty1.service.d\ncat > /etc/systemd/system/getty@tty1.service.d/autologin.conf << 'EOFINNER'\n[Service]\nExecStart=\nExecStart=-/sbin/agetty --autologin live --noclear %I $TERM\nEOFINNER\n\n# Configure hostname\necho \"jnarddc-wiper\" > /etc/hostname\n\n# Clean up\napt-get autoremove -y\napt-get autoclean\nrm -rf /var/lib/apt/lists/*\nEOF\n\n    chmod +x \"$WORK_DIR/chroot/configure.sh\"\n    chroot \"$WORK_DIR/chroot\" /configure.sh\n    rm \"$WORK_DIR/chroot/configure.sh\"\n    \n    log_info \"System configured\"\n}\n\n# Install JNARDDC wiping utilities\ninstall_wipe_utilities() {\n    log_step \"Installing JNARDDC wiping utilities...\"\n    \n    # Create the main wiping application\n    mkdir -p \"$WORK_DIR/chroot/opt/jnarddc-wiper\"\n    \n    cat > \"$WORK_DIR/chroot/opt/jnarddc-wiper/secure-wipe.py\" << 'EOF'\n#!/usr/bin/env python3\n\"\"\"\nJNARDDC Secure Data Wiper\nNIST SP 800-88 Rev. 1 Compliant Data Sanitization Tool\nMinistry of Mines, Government of India\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport hashlib\nimport secrets\nimport subprocess\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass NISTDataWiper:\n    def __init__(self):\n        self.methods = {\n            'clear': {\n                'name': 'NIST Clear (Single Pass)',\n                'passes': 1,\n                'patterns': [b'\\x00'],\n                'description': 'Single pass overwrite with zeros'\n            },\n            'purge': {\n                'name': 'NIST Purge (3-Pass)',\n                'passes': 3,\n                'patterns': ['random', 'complement', 'random'],\n                'description': 'Three pass purge for enhanced security'\n            },\n            'dod3': {\n                'name': 'DoD 5220.22-M (3-Pass)',\n                'passes': 3,\n                'patterns': [b'\\x00', b'\\xff', 'random'],\n                'description': 'DoD standard 3-pass method'\n            }\n        }\n        \n    def detect_devices(self):\n        \"\"\"Detect available storage devices\"\"\"\n        devices = []\n        try:\n            result = subprocess.run(['lsblk', '-J', '-o', 'NAME,SIZE,TYPE,MOUNTPOINT'], \n                                  capture_output=True, text=True)\n            data = json.loads(result.stdout)\n            \n            for device in data.get('blockdevices', []):\n                if device['type'] == 'disk' and not device.get('mountpoint'):\n                    devices.append({\n                        'name': f\"/dev/{device['name']}\",\n                        'size': device['size'],\n                        'type': device['type']\n                    })\n        except Exception as e:\n            print(f\"Error detecting devices: {e}\")\n            \n        return devices\n    \n    def wipe_device(self, device_path, method='clear', progress_callback=None):\n        \"\"\"Perform secure wipe on device\"\"\"\n        if method not in self.methods:\n            raise ValueError(f\"Unknown method: {method}\")\n            \n        method_info = self.methods[method]\n        print(f\"Starting {method_info['name']} on {device_path}\")\n        \n        # Get device size\n        try:\n            with open(device_path, 'rb') as f:\n                f.seek(0, 2)  # Seek to end\n                device_size = f.tell()\n        except Exception as e:\n            raise RuntimeError(f\"Cannot access device {device_path}: {e}\")\n        \n        wipe_record = {\n            'device': device_path,\n            'method': method,\n            'started_at': datetime.now().isoformat(),\n            'device_size': device_size,\n            'passes_completed': 0,\n            'verification': None\n        }\n        \n        # Perform wipe passes\n        for pass_num in range(method_info['passes']):\n            pattern = method_info['patterns'][pass_num]\n            print(f\"Pass {pass_num + 1}/{method_info['passes']}\")\n            \n            if pattern == 'random':\n                self._write_random_pass(device_path, device_size, progress_callback)\n            elif pattern == 'complement':\n                self._write_complement_pass(device_path, device_size, progress_callback)\n            else:\n                self._write_pattern_pass(device_path, device_size, pattern, progress_callback)\n            \n            wipe_record['passes_completed'] = pass_num + 1\n            \n            # Sync after each pass\n            subprocess.run(['sync'], check=True)\n        \n        wipe_record['completed_at'] = datetime.now().isoformat()\n        \n        # Verification\n        print(\"Performing verification...\")\n        verification_result = self._verify_wipe(device_path, device_size)\n        wipe_record['verification'] = verification_result\n        \n        # Generate certificate\n        cert_path = self._generate_certificate(wipe_record)\n        wipe_record['certificate_path'] = cert_path\n        \n        return wipe_record\n    \n    def _write_random_pass(self, device_path, size, callback=None):\n        \"\"\"Write random data pass\"\"\"\n        chunk_size = 1024 * 1024  # 1MB chunks\n        written = 0\n        \n        with open(device_path, 'r+b') as device:\n            while written < size:\n                remaining = min(chunk_size, size - written)\n                random_data = secrets.token_bytes(remaining)\n                device.write(random_data)\n                written += remaining\n                \n                if callback:\n                    callback(written, size)\n    \n    def _write_pattern_pass(self, device_path, size, pattern, callback=None):\n        \"\"\"Write pattern data pass\"\"\"\n        chunk_size = 1024 * 1024\n        pattern_chunk = pattern * (chunk_size // len(pattern) + 1)[:chunk_size]\n        written = 0\n        \n        with open(device_path, 'r+b') as device:\n            while written < size:\n                remaining = min(chunk_size, size - written)\n                device.write(pattern_chunk[:remaining])\n                written += remaining\n                \n                if callback:\n                    callback(written, size)\n    \n    def _write_complement_pass(self, device_path, size, callback=None):\n        \"\"\"Write complement of previous data\"\"\"\n        chunk_size = 1024 * 1024\n        written = 0\n        \n        with open(device_path, 'r+b') as device:\n            device.seek(0)\n            while written < size:\n                remaining = min(chunk_size, size - written)\n                data = device.read(remaining)\n                if len(data) == 0:\n                    break\n                \n                # Complement the data\n                complement = bytes(~b & 0xff for b in data)\n                device.seek(-len(data), 1)\n                device.write(complement)\n                written += len(data)\n                \n                if callback:\n                    callback(written, size)\n    \n    def _verify_wipe(self, device_path, size):\n        \"\"\"Verify wipe by random sampling\"\"\"\n        sample_size = min(1024 * 1024, size // 1000)  # Sample 0.1% or 1MB max\n        samples = 10\n        verification_passed = 0\n        \n        with open(device_path, 'rb') as device:\n            for _ in range(samples):\n                # Random position\n                pos = secrets.randbelow(size - sample_size)\n                device.seek(pos)\n                data = device.read(sample_size)\n                \n                # Check if data is all zeros (for clear method)\n                if all(b == 0 for b in data):\n                    verification_passed += 1\n        \n        success_rate = (verification_passed / samples) * 100\n        return {\n            'samples_checked': samples,\n            'samples_passed': verification_passed,\n            'success_rate': success_rate,\n            'passed': success_rate >= 95\n        }\n    \n    def _generate_certificate(self, wipe_record):\n        \"\"\"Generate wipe certificate\"\"\"\n        cert_dir = Path('/tmp/wipe-certificates')\n        cert_dir.mkdir(exist_ok=True)\n        \n        cert_id = hashlib.sha256(f\"{wipe_record['device']}{wipe_record['started_at']}\".encode()).hexdigest()[:16]\n        cert_path = cert_dir / f\"JNARDDC-CERT-{cert_id}.json\"\n        \n        certificate = {\n            'version': '1.0',\n            'issuer': 'JNARDDC Bootable Secure Wiper',\n            'certificate_id': f\"BOOT-{cert_id}\",\n            'device_info': {\n                'path': wipe_record['device'],\n                'size_bytes': wipe_record['device_size']\n            },\n            'sanitization': {\n                'method': wipe_record['method'],\n                'started_at': wipe_record['started_at'],\n                'completed_at': wipe_record['completed_at'],\n                'passes_completed': wipe_record['passes_completed']\n            },\n            'verification': wipe_record['verification'],\n            'compliance': 'NIST SP 800-88 Rev. 1',\n            'generated_at': datetime.now().isoformat(),\n            'signature': 'JNARDDC-BOOTABLE-WIPER-v1.0'\n        }\n        \n        with open(cert_path, 'w') as f:\n            json.dump(certificate, f, indent=2)\n        \n        return str(cert_path)\n\ndef main():\n    print(\"\\n\" + \"=\"*60)\n    print(\"   JNARDDC Secure Data Wiper (Bootable Edition)\")\n    print(\"   NIST SP 800-88 Rev. 1 Compliant\")\n    print(\"   Ministry of Mines, Government of India\")\n    print(\"=\"*60 + \"\\n\")\n    \n    wiper = NISTDataWiper()\n    \n    # Detect devices\n    print(\"Detecting storage devices...\")\n    devices = wiper.detect_devices()\n    \n    if not devices:\n        print(\"No suitable devices found for wiping.\")\n        return\n    \n    print(\"\\nAvailable devices:\")\n    for i, device in enumerate(devices):\n        print(f\"  {i+1}. {device['name']} ({device['size']})\")\n    \n    # Device selection\n    while True:\n        try:\n            choice = int(input(\"\\nSelect device (number): \")) - 1\n            if 0 <= choice < len(devices):\n                selected_device = devices[choice]\n                break\n            else:\n                print(\"Invalid selection.\")\n        except ValueError:\n            print(\"Please enter a number.\")\n    \n    # Method selection\n    print(\"\\nAvailable methods:\")\n    methods = list(wiper.methods.keys())\n    for i, method in enumerate(methods):\n        info = wiper.methods[method]\n        print(f\"  {i+1}. {info['name']} - {info['description']}\")\n    \n    while True:\n        try:\n            choice = int(input(\"\\nSelect method (number): \")) - 1\n            if 0 <= choice < len(methods):\n                selected_method = methods[choice]\n                break\n            else:\n                print(\"Invalid selection.\")\n        except ValueError:\n            print(\"Please enter a number.\")\n    \n    # Confirmation\n    print(f\"\\nWARNING: This will permanently destroy all data on {selected_device['name']}\")\n    confirm = input(\"Type 'CONFIRM' to proceed: \")\n    \n    if confirm != 'CONFIRM':\n        print(\"Operation cancelled.\")\n        return\n    \n    # Progress callback\n    def progress_callback(written, total):\n        percent = (written / total) * 100\n        print(f\"\\rProgress: {percent:.1f}%\", end='', flush=True)\n    \n    try:\n        # Perform wipe\n        print(f\"\\nStarting secure wipe of {selected_device['name']}...\")\n        result = wiper.wipe_device(selected_device['name'], selected_method, progress_callback)\n        \n        print(f\"\\n\\nWipe completed successfully!\")\n        print(f\"Method: {wiper.methods[selected_method]['name']}\")\n        print(f\"Passes: {result['passes_completed']}\")\n        print(f\"Verification: {result['verification']['success_rate']:.1f}% success\")\n        print(f\"Certificate: {result['certificate_path']}\")\n        \n    except Exception as e:\n        print(f\"\\nError during wipe: {e}\")\n        return 1\n    \n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\nEOF\n\n    chmod +x \"$WORK_DIR/chroot/opt/jnarddc-wiper/secure-wipe.py\"\n    \n    # Create desktop shortcut\n    mkdir -p \"$WORK_DIR/chroot/home/live/Desktop\"\n    cat > \"$WORK_DIR/chroot/home/live/Desktop/JNARDDC-Wiper.desktop\" << 'EOF'\n[Desktop Entry]\nName=JNARDDC Secure Wiper\nComment=NIST-compliant secure data wiping tool\nExec=sudo python3 /opt/jnarddc-wiper/secure-wipe.py\nIcon=security-high\nTerminal=true\nType=Application\nCategories=System;Security;\nEOF\n    \n    chmod +x \"$WORK_DIR/chroot/home/live/Desktop/JNARDDC-Wiper.desktop\"\n    chown 1000:1000 \"$WORK_DIR/chroot/home/live/Desktop/JNARDDC-Wiper.desktop\"\n    \n    log_info \"JNARDDC wiping utilities installed\"\n}\n\n# Create startup script\ncreate_startup_script() {\n    log_step \"Creating startup script...\"\n    \n    cat > \"$WORK_DIR/chroot/home/live/.bashrc\" << 'EOF'\n# JNARDDC Secure Wiper Bootable Environment\n\necho \"\"\necho \"======================================================\"\necho \"  JNARDDC Secure Data Wiper (Bootable Edition)\"\necho \"  NIST SP 800-88 Rev. 1 Compliant\"\necho \"  Ministry of Mines, Government of India\"\necho \"======================================================\"\necho \"\"\necho \"Available commands:\"\necho \"  secure-wipe    - Start the secure wiping tool\"\necho \"  lsblk          - List available storage devices\"\necho \"  exit           - Shutdown the system\"\necho \"\"\n\n# Alias for easy access\nalias secure-wipe='sudo python3 /opt/jnarddc-wiper/secure-wipe.py'\nEOF\n    \n    chown 1000:1000 \"$WORK_DIR/chroot/home/live/.bashrc\"\n    \n    log_info \"Startup script created\"\n}\n\n# Create the live filesystem\ncreate_live_filesystem() {\n    log_step \"Creating live filesystem...\"\n    \n    # Unmount chroot filesystems\n    umount \"$WORK_DIR/chroot/dev/pts\" || true\n    umount \"$WORK_DIR/chroot/dev\" || true\n    umount \"$WORK_DIR/chroot/proc\" || true\n    umount \"$WORK_DIR/chroot/sys\" || true\n    \n    # Create squashfs\n    mksquashfs \"$WORK_DIR/chroot\" \"$WORK_DIR/image/live/filesystem.squashfs\" \\\n        -e boot\n    \n    # Create filesystem.size\n    printf $(du -sx --block-size=1 \"$WORK_DIR/chroot\" | cut -f1) > \\\n        \"$WORK_DIR/image/live/filesystem.size\"\n    \n    log_info \"Live filesystem created\"\n}\n\n# Extract kernel and initrd\nextract_kernel() {\n    log_step \"Extracting kernel and initrd...\"\n    \n    mkdir -p \"$WORK_DIR/image/live\"\n    \n    # Find kernel and initrd\n    KERNEL=$(ls \"$WORK_DIR/chroot/boot/vmlinuz-\"* | head -n1)\n    INITRD=$(ls \"$WORK_DIR/chroot/boot/initrd.img-\"* | head -n1)\n    \n    if [ -z \"$KERNEL\" ] || [ -z \"$INITRD\" ]; then\n        log_error \"Kernel or initrd not found\"\n        exit 1\n    fi\n    \n    cp \"$KERNEL\" \"$WORK_DIR/image/live/vmlinuz\"\n    cp \"$INITRD\" \"$WORK_DIR/image/live/initrd\"\n    \n    log_info \"Kernel and initrd extracted\"\n}\n\n# Create bootloader configuration\ncreate_bootloader() {\n    log_step \"Creating bootloader configuration...\"\n    \n    mkdir -p \"$WORK_DIR/image/isolinux\"\n    \n    # Copy isolinux files\n    cp /usr/lib/ISOLINUX/isolinux.bin \"$WORK_DIR/image/isolinux/\"\n    cp /usr/lib/syslinux/modules/bios/menu.c32 \"$WORK_DIR/image/isolinux/\"\n    cp /usr/lib/syslinux/modules/bios/ldlinux.c32 \"$WORK_DIR/image/isolinux/\"\n    \n    # Create isolinux.cfg\n    cat > \"$WORK_DIR/image/isolinux/isolinux.cfg\" << EOF\nDEFAULT menu.c32\nPROMPT 0\nMENU TITLE JNARDDC Secure Data Wiper\nMENU BACKGROUND splash.png\n\nLABEL live\n    MENU LABEL Start JNARDDC Secure Wiper\n    MENU DEFAULT\n    KERNEL /live/vmlinuz\n    APPEND initrd=/live/initrd boot=live components username=live hostname=jnarddc-wiper\n\nLABEL memtest\n    MENU LABEL Memory Test\n    KERNEL /live/memtest86+\n\nLABEL hdt\n    MENU LABEL Hardware Detection Tool\n    COM32 hdt.c32\nEOF\n    \n    # Copy memtest86+\n    if [ -f \"$WORK_DIR/chroot/boot/memtest86+.bin\" ]; then\n        cp \"$WORK_DIR/chroot/boot/memtest86+.bin\" \"$WORK_DIR/image/live/memtest86+\"\n    fi\n    \n    log_info \"Bootloader configuration created\"\n}\n\n# Create the ISO image\ncreate_iso() {\n    log_step \"Creating ISO image...\"\n    \n    OUTPUT_DIR=\"$(pwd)\"\n    cd \"$WORK_DIR/image\"\n    \n    xorriso -as mkisofs \\\n        -iso-level 3 \\\n        -full-iso9660-filenames \\\n        -volid \"$VOLUME_LABEL\" \\\n        -appid \"JNARDDC Secure Data Wiper v1.0\" \\\n        -publisher \"Ministry of Mines, Government of India\" \\\n        -preparer \"JNARDDC - Jawaharlal Nehru Aluminium Research Development and Design Centre\" \\\n        -eltorito-boot isolinux/isolinux.bin \\\n        -eltorito-catalog isolinux/boot.cat \\\n        -no-emul-boot \\\n        -boot-load-size 4 \\\n        -boot-info-table \\\n        -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \\\n        -output \"$OUTPUT_DIR/$ISO_NAME\" \\\n        -graft-points \\\n        \".\" \\\n        \"/isolinux/isolinux.bin=isolinux/isolinux.bin\" \\\n        \"/isolinux/boot.cat=isolinux/boot.cat\"\n    \n    cd \"$OUTPUT_DIR\"\n    \n    # Generate checksums\n    sha256sum \"$ISO_NAME\" > \"${ISO_NAME}.sha256\"\n    md5sum \"$ISO_NAME\" > \"${ISO_NAME}.md5\"\n    \n    log_info \"ISO image created: $ISO_NAME\"\n    log_info \"Size: $(du -h \"$ISO_NAME\" | cut -f1)\"\n    log_info \"SHA256: $(cat \"${ISO_NAME}.sha256\" | cut -d' ' -f1)\"\n}\n\n# Cleanup function\ncleanup() {\n    log_step \"Cleaning up...\"\n    \n    # Unmount any remaining mounts\n    umount \"$WORK_DIR/chroot/dev/pts\" 2>/dev/null || true\n    umount \"$WORK_DIR/chroot/dev\" 2>/dev/null || true\n    umount \"$WORK_DIR/chroot/proc\" 2>/dev/null || true\n    umount \"$WORK_DIR/chroot/sys\" 2>/dev/null || true\n    \n    # Remove work directory\n    rm -rf \"$WORK_DIR\"\n    \n    log_info \"Cleanup completed\"\n}\n\n# Main execution\nmain() {\n    log_info \"Starting JNARDDC Secure Data Wiper ISO creation...\"\n    log_info \"Build date: $BUILD_DATE\"\n    \n    # Set trap for cleanup on exit\n    trap cleanup EXIT\n    \n    check_dependencies\n    setup_workspace\n    create_base_system\n    configure_system\n    install_wipe_utilities\n    create_startup_script\n    create_live_filesystem\n    extract_kernel\n    create_bootloader\n    create_iso\n    \n    log_info \"ISO creation completed successfully!\"\n    log_info \"Bootable ISO: $ISO_NAME\"\n    log_warn \"Boot from this ISO to access the secure wiping environment\"\n    log_warn \"All data on target devices will be permanently destroyed\"\n}\n\n# Run main function\nmain \"$@\"